// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/

export const commands = {
	async greet(name: string): Promise<string> {
		return await TAURI_INVOKE('greet', { name })
	},
	/**
	 * Submit a completed assessment
	 */
	async submitAssessment(
		request: SubmitAssessmentRequest
	): Promise<Result<AssessmentResponse, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('submit_assessment', { request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * Delete an assessment response
	 */
	async deleteAssessment(id: number): Promise<Result<null, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('delete_assessment', { id }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * Delete an assessment type (defensive - prevents deletion if children exist)
	 */
	async deleteAssessmentType(id: number): Promise<Result<null, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('delete_assessment_type', { id }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * Get all available assessment types
	 */
	async getAssessmentTypes(): Promise<Result<AssessmentType[], CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_assessment_types') }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * Get questions for a specific assessment type
	 */
	async getAssessmentQuestions(
		assessmentTypeCode: string
	): Promise<Result<AssessmentQuestion[], CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_assessment_questions', { assessmentTypeCode }),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * Get assessment history with optional filtering
	 */
	async getAssessmentHistory(
		assessmentTypeCode: string | null,
		fromDate: string | null,
		toDate: string | null,
		limit: number | null
	): Promise<Result<AssessmentResponse[], CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_assessment_history', {
					assessmentTypeCode,
					fromDate,
					toDate,
					limit,
				}),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * Get a single assessment response by ID
	 *
	 * # Security Note
	 *
	 * This endpoint allows fetching any assessment by ID without user authentication.
	 * This is a known limitation acceptable for a single-user desktop application.
	 * If multi-user support is added, this endpoint should be protected with user
	 * authentication and ownership verification.
	 */
	async getAssessmentResponse(id: number): Promise<Result<AssessmentResponse, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_assessment_response', { id }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * Get the most recent assessment for a specific type
	 */
	async getLatestAssessment(
		assessmentTypeCode: string
	): Promise<Result<AssessmentResponse | null, CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_latest_assessment', { assessmentTypeCode }),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * Get all draft assessments (not completed)
	 */
	async getDraftAssessments(): Promise<Result<AssessmentResponse[], CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_draft_assessments') }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async logMood(request: LogMoodRequest): Promise<Result<MoodCheckin, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('log_mood', { request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async createActivity(request: CreateActivityRequest): Promise<Result<Activity, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('create_activity', { request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async updateActivity(
		id: number,
		request: UpdateActivityRequest
	): Promise<Result<Activity, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('update_activity', { id, request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async deleteActivity(id: number): Promise<Result<null, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('delete_activity', { id }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async deleteMoodCheckin(id: number): Promise<Result<null, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('delete_mood_checkin', { id }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async getMoodHistory(
		fromDate: string | null,
		toDate: string | null,
		limit: number | null
	): Promise<Result<MoodCheckin[], CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_mood_history', { fromDate, toDate, limit }),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async getMoodCheckin(id: number): Promise<Result<MoodCheckin, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_mood_checkin', { id }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async getMoodStats(
		fromDate: string | null,
		toDate: string | null
	): Promise<Result<MoodStats, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_mood_stats', { fromDate, toDate }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async getActivities(includeDeleted: boolean): Promise<Result<Activity[], CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_activities', { includeDeleted }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * T126: Get assessment chart data for visualization
	 */
	async getAssessmentChartData(
		code: string,
		timeRange: TimeRange,
		fromDate: string | null,
		toDate: string | null
	): Promise<Result<AssessmentChartData, CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_assessment_chart_data', {
					code,
					timeRange,
					fromDate,
					toDate,
				}),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * T144: Get mood chart data for visualization
	 */
	async getMoodChartData(
		timeRange: TimeRange,
		fromDate: string | null,
		toDate: string | null,
		groupByActivity: boolean
	): Promise<Result<MoodChartData, CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_mood_chart_data', {
					timeRange,
					fromDate,
					toDate,
					groupByActivity,
				}),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * T165: Create a new assessment schedule
	 */
	async createSchedule(
		request: CreateScheduleRequest
	): Promise<Result<AssessmentSchedule, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('create_schedule', { request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * T166: Update an existing schedule
	 */
	async updateSchedule(
		id: number,
		request: UpdateScheduleRequest
	): Promise<Result<AssessmentSchedule, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('update_schedule', { id, request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * T167: Delete a schedule
	 */
	async deleteSchedule(id: number): Promise<Result<null, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('delete_schedule', { id }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * T168: Get all schedules (optionally filtered to enabled only)
	 */
	async getSchedules(enabledOnly: boolean): Promise<Result<AssessmentSchedule[], CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_schedules', { enabledOnly }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * T169: Get a single schedule by ID
	 */
	async getSchedule(id: number): Promise<Result<AssessmentSchedule, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_schedule', { id }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async createActivityGroup(
		request: CreateActivityGroupRequest
	): Promise<Result<ActivityGroup, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('create_activity_group', { request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async updateActivityGroup(
		id: number,
		request: UpdateActivityGroupRequest
	): Promise<Result<ActivityGroup, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('update_activity_group', { id, request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async deleteActivityGroup(id: number): Promise<Result<null, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('delete_activity_group', { id }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async getActivityGroups(): Promise<Result<ActivityGroup[], CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('get_activity_groups') }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async logActivity(request: LogActivityRequest): Promise<Result<ActivityLog, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('log_activity', { request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	/**
	 * Update notes for an existing activity log.
	 *
	 * Frontend usage:
	 * - Allows editing/clearing notes from ActivityLogHistory
	 * - Enforces same constraints as log_activity (<= 500 chars, trimmed)
	 */
	async updateActivityLog(
		id: number,
		notes: string | null
	): Promise<Result<ActivityLog, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('update_activity_log', { id, notes }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async getActivityLogs(
		activityId: number | null,
		startDate: string | null,
		endDate: string | null
	): Promise<Result<ActivityLog[], CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_activity_logs', { activityId, startDate, endDate }),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async setActivityGoal(
		request: SetActivityGoalRequest
	): Promise<Result<ActivityGoal, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('set_activity_goal', { request }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async updateActivityGoal(
		goalId: number,
		targetValue: number,
		periodDays: number
	): Promise<Result<ActivityGoal, CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('update_activity_goal', { goalId, targetValue, periodDays }),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async deleteActivityGoal(goalId: number): Promise<Result<null, CommandError>> {
		try {
			return { status: 'ok', data: await TAURI_INVOKE('delete_activity_goal', { goalId }) }
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async getActivityGoals(
		activityId: number | null,
		groupId: number | null
	): Promise<Result<ActivityGoal[], CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_activity_goals', { activityId, groupId }),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async getActivityFrequency(
		activityId: number,
		startDate: string,
		endDate: string
	): Promise<Result<ActivityFrequency, CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_activity_frequency', { activityId, startDate, endDate }),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async getActivityTrend(
		activityId: number,
		periodDays: number,
		currentTime: string
	): Promise<Result<ActivityTrend, CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('get_activity_trend', { activityId, periodDays, currentTime }),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
	async checkGoalProgress(
		goalId: number,
		currentTime: string
	): Promise<Result<GoalProgress, CommandError>> {
		try {
			return {
				status: 'ok',
				data: await TAURI_INVOKE('check_goal_progress', { goalId, currentTime }),
			}
		} catch (e) {
			if (e instanceof Error) throw e
			else return { status: 'error', error: e as any }
		}
	},
}

/** user-defined events **/

/** user-defined constants **/

/** user-defined types **/

/**
 * Activity model
 *
 * Represents an activity that can be associated with mood check-ins or tracked
 * independently via activity logging. This is the single source of truth for
 * the Activity type across all features (mood, activities, visualization).
 *
 * The `HexColor` newtype ensures color values are always valid hex format.
 */
export type Activity = {
	id: number
	group_id: number
	name: string
	/**
	 * Optional color in validated hex format (#RGB, #RRGGBB, or #RRGGBBAA)
	 */
	color: HexColor | null
	icon: string | null
	created_at: string
	deleted_at: string | null
}
/**
 * Activity correlation with mood
 */
export type ActivityCorrelation = {
	activity: Activity
	average_mood: number
	checkin_count: number
}
/**
 * Activity frequency report showing days per week
 */
export type ActivityFrequency = {
	activity_id: number
	/**
	 * Number of unique days with activity logs
	 */
	unique_days: number
	/**
	 * Total number of activity logs (may be multiple per day)
	 */
	total_logs: number
	/**
	 * Average days per week: (unique_days / num_weeks)
	 */
	days_per_week: number
	/**
	 * Start of analysis period (ISO 8601)
	 */
	period_start: string
	/**
	 * End of analysis period (ISO 8601)
	 */
	period_end: string
}
/**
 * Activity Goal model
 *
 * Represents a user-defined goal for tracking activity completion or improvement.
 *
 * # Goal Target (Mutually Exclusive)
 *
 * Goals must target either:
 * - A specific `activity_id` (e.g., "Exercise 3 times per week")
 * - An entire `group_id` (e.g., "Do any social activity 5 times per week")
 *
 * Setting both or neither is invalid and enforced by:
 * - Database CHECK constraint: `NOT (activity_id IS NOT NULL AND group_id IS NOT NULL)`
 * - Validation layer: `validate_goal_target_exclusivity()` function
 *
 * # Goal Types
 *
 * - `"days_per_period"`: Track frequency of activity within a time period
 * - Example: "Exercise 3 days per 7-day period"
 * - `target_value`: number of days activity should be performed
 * - `period_days`: rolling window size in days
 *
 * - `"percent_improvement"`: Track improvement over baseline period
 * - Example: "Increase meditation by 20% over 30-day baseline"
 * - `target_value`: percentage improvement (e.g., 20 = 20%)
 * - `period_days`: baseline comparison period in days
 *
 * # Soft Deletes
 *
 * Goals use soft delete pattern via `deleted_at` timestamp, allowing:
 * - Historical goal tracking and analysis
 * - Recovery of accidentally deleted goals
 * - Audit trail of goal changes over time
 */
export type ActivityGoal = {
	id: number
	/**
	 * ID of specific activity this goal targets (mutually exclusive with group_id)
	 */
	activity_id: number | null
	/**
	 * ID of activity group this goal targets (mutually exclusive with activity_id)
	 */
	group_id: number | null
	/**
	 * Type of goal: DaysPerPeriod or PercentImprovement
	 */
	goal_type: GoalType
	/**
	 * Target value: days count for DaysPerPeriod, percentage for PercentImprovement
	 */
	target_value: number
	/**
	 * Time period in days for goal measurement or baseline comparison
	 */
	period_days: number
	/**
	 * ISO 8601 timestamp when goal was created
	 */
	created_at: string
	/**
	 * ISO 8601 timestamp when goal was soft-deleted (None if active)
	 */
	deleted_at: string | null
}
/**
 * Activity Group model
 */
export type ActivityGroup = {
	id: number
	name: string
	description: string | null
	created_at: string
	deleted_at: string | null
}
/**
 * Activity Log model
 */
export type ActivityLog = {
	id: number
	activity_id: number
	logged_at: string
	created_at: string
	notes: string | null
	deleted_at: string | null
}
/**
 * Activity-specific mood data for correlation analysis
 */
export type ActivityMoodData = {
	activity: Activity
	average_mood: number
	data_points: ChartDataPoint[]
}
/**
 * Activity trend report comparing current vs previous period
 */
export type ActivityTrend = {
	activity_id: number
	/**
	 * Unique days in current period
	 */
	current_period_days: number
	/**
	 * Unique days in previous period (same duration)
	 */
	previous_period_days: number
	/**
	 * Difference: current - previous
	 */
	change_days: number
	/**
	 * Percentage change: ((current - previous) / previous) * 100
	 */
	change_percentage: number
	/**
	 * Trend classification based on change_percentage
	 */
	trend: Trend
}
/**
 * Assessment chart data with thresholds and statistics
 */
export type AssessmentChartData = {
	assessment_type: AssessmentType
	data_points: ChartDataPoint[]
	thresholds: ThresholdLine[]
	statistics: ChartStatistics
}
/**
 * Assessment code identifying the assessment type
 *
 * Each assessment has a specific number of questions and scoring algorithm.
 */
export type AssessmentCode =
	/**
	 * Patient Health Questionnaire-9 (depression screening)
	 * 9 questions, score 0-27
	 */
	| 'PHQ9'
	/**
	 * Generalized Anxiety Disorder-7 (anxiety screening)
	 * 7 questions, score 0-21
	 */
	| 'GAD7'
	/**
	 * Center for Epidemiologic Studies Depression Scale
	 * 20 questions, score 0-60
	 */
	| 'CESD'
	/**
	 * Overall Anxiety Severity and Impairment Scale
	 * 5 questions, score 0-20
	 */
	| 'OASIS'
/**
 * Assessment question
 */
export type AssessmentQuestion = { number: number; text: string; options: string[] }
/**
 * Assessment response with calculated score
 */
export type AssessmentResponse = {
	id: number
	assessment_type: AssessmentType
	responses: number[]
	total_score: number
	severity_level: SeverityLevel
	completed_at: string
	notes: string | null
	status: AssessmentStatus
}
/**
 * Assessment schedule configuration
 */
export type AssessmentSchedule = {
	id: number
	assessment_type_id: number
	assessment_type_code: string
	assessment_type_name: string
	frequency: ScheduleFrequency
	time_of_day: string
	day_of_week: number | null
	day_of_month: number | null
	enabled: boolean
	last_triggered_at: string | null
	created_at: string
	updated_at: string
}
/**
 * Assessment status (draft or completed)
 *
 * Draft assessments have incomplete responses; completed have full responses with scores.
 */
export type AssessmentStatus = 'draft' | 'completed'
/**
 * Assessment type (PHQ-9, GAD-7, CES-D, OASIS)
 */
export type AssessmentType = {
	id: number
	/**
	 * Assessment code using typed enum for compile-time validation
	 */
	code: AssessmentCode
	name: string
	description: string | null
	question_count: number
	min_score: number
	max_score: number
}
/**
 * Chart data point for time-series visualization
 */
export type ChartDataPoint = { timestamp: string; value: number; label: string | null }
/**
 * Chart statistics (min, max, average, trend)
 */
export type ChartStatistics = {
	min: number
	max: number
	average: number
	trend: TrendDirection
	total_assessments: number
}
/**
 * Structured error response for Tauri commands that provides:
 * - Human-readable error message
 * - Machine-readable error type for conditional logic
 * - Retry flag to guide client-side retry behavior
 *
 * This enables the frontend to:
 * - Make type-safe decisions about error handling
 * - Implement smart retry logic without string parsing
 * - Display appropriate error messages to users
 */
export type CommandError = {
	/**
	 * Human-readable error message
	 */
	message: string
	/**
	 * Machine-readable error type for conditional logic
	 * Auto-generated to TypeScript via specta for type safety
	 */
	error_type: ErrorType
	/**
	 * Whether this error is retryable (e.g., database locks, transient network issues)
	 * - true: Client should retry the operation (e.g., SQLITE_BUSY, lock timeout)
	 * - false: Client should not retry (e.g., validation error, not found)
	 */
	retryable: boolean
}
/**
 * Request to create an activity group
 */
export type CreateActivityGroupRequest = { name: string; description: string | null }
/**
 * Request to create an activity
 */
export type CreateActivityRequest = {
	name: string
	/**
	 * Color validated on deserialization via HexColor newtype
	 */
	color: HexColor | null
	icon: string | null
	group_id: number
}
/**
 * Request to create a new schedule
 */
export type CreateScheduleRequest = {
	assessment_type_id: number
	frequency: ScheduleFrequency
	time_of_day: string
	day_of_week: number | null
	day_of_month: number | null
}
/**
 * Error type enumeration for type-safe error classification
 *
 * This enum is auto-generated to TypeScript via specta, eliminating duplication
 * between Rust and TypeScript error type constants.
 */
export type ErrorType =
	| 'validation'
	| 'not_found'
	| 'database_error'
	| 'database_locked'
	| 'lock_poisoned'
	| 'constraint_violation'
	| 'duplicate'
	| 'transaction_failure'
	| 'no_data'
	| 'calculation_error'
	| 'transient'
	| 'internal'
	| 'config'
	| 'io_error'
	| 'serialization'
/**
 * Goal progress report showing current vs target values
 */
export type GoalProgress = {
	goal_id: number
	/**
	 * Current value achieved (days or percentage depending on goal_type)
	 */
	current_value: number
	/**
	 * Target value from goal definition
	 */
	target_value: number
	/**
	 * Progress percentage: (current / target) * 100
	 */
	percentage: number
	/**
	 * Whether goal has been achieved (percentage >= 100)
	 */
	is_achieved: boolean
	/**
	 * Start of measurement period (ISO 8601)
	 */
	period_start: string
	/**
	 * End of measurement period (ISO 8601)
	 */
	period_end: string
}
/**
 * Goal type for activity tracking
 *
 * Replaces string matching for `"days_per_period"` and `"percent_improvement"`.
 */
export type GoalType =
	/**
	 * Track frequency: achieve X days within a Y-day period
	 * Example: "Exercise 3 days per 7-day period"
	 */
	| 'days_per_period'
	/**
	 * Track improvement: increase activity by X% over baseline
	 * Example: "Increase meditation by 20% over 30-day baseline"
	 */
	| 'percent_improvement'
/**
 * Validated hex color string
 *
 * Newtype wrapper ensuring the color is a valid hex format:
 * - #RGB (4 chars, e.g., #F00 for red)
 * - #RRGGBB (7 chars, e.g., #FF0000 for red)
 * - #RRGGBBAA (9 chars, e.g., #FF000080 for semi-transparent red)
 */
export type HexColor = string
/**
 * Request to log an activity
 */
export type LogActivityRequest = {
	activity_id: number
	logged_at: string | null
	notes: string | null
}
/**
 * Request to log a mood check-in
 */
export type LogMoodRequest = { mood_rating: number; activity_ids: number[]; notes: string | null }
/**
 * Mood chart data with activity breakdown
 */
export type MoodChartData = {
	data_points: ChartDataPoint[]
	activity_breakdown: ActivityMoodData[]
	statistics: MoodStatistics
}
/**
 * Mood check-in model
 *
 * Tracks a mood rating on a 7-point scale with optional activities and notes.
 * The `MoodRating` newtype ensures the value is always valid (1-7).
 */
export type MoodCheckin = {
	id: number
	/**
	 * Mood rating (1-7) with type-enforced validation
	 */
	mood_rating: MoodRating
	notes: string | null
	activities: Activity[]
	created_at: string
}
/**
 * Mood rating on a 7-point scale
 *
 * Newtype wrapper ensuring the rating is always valid (1-7).
 * - 1 = Terrible
 * - 2 = Very Bad
 * - 3 = Bad
 * - 4 = Ok
 * - 5 = Good
 * - 6 = Very Good
 * - 7 = Excellent
 */
export type MoodRating = number
/**
 * Mood statistics (min, max, average, median, mode)
 */
export type MoodStatistics = {
	min: number
	max: number
	average: number
	median: number
	mode: number
	total_checkins: number
	checkins_per_day: number
}
/**
 * Mood statistics
 */
export type MoodStats = {
	average_mood: number
	total_checkins: number
	mood_distribution: { [key in number]: number }
	activity_correlations: ActivityCorrelation[]
}
/**
 * Schedule frequency options
 */
export type ScheduleFrequency = 'daily' | 'weekly' | 'biweekly' | 'monthly'
/**
 * Request to set an activity goal
 */
export type SetActivityGoalRequest = {
	activity_id: number | null
	group_id: number | null
	/**
	 * Type of goal: DaysPerPeriod or PercentImprovement
	 */
	goal_type: GoalType
	target_value: number
	period_days: number
}
/**
 * Severity level for assessment scores
 *
 * Replaces string constants `SEVERITY_*`.
 * Each assessment type has different score thresholds for these levels.
 */
export type SeverityLevel =
	| 'minimal'
	| 'mild'
	| 'moderate'
	| 'moderately_severe'
	| 'severe'
	| 'unknown'
/**
 * Request to submit assessment
 */
export type SubmitAssessmentRequest = {
	assessment_type_code: string
	responses: number[]
	notes: string | null
	status?: AssessmentStatus
}
/**
 * Threshold line for severity level visualization
 */
export type ThresholdLine = { label: string; value: number; color: string }
/**
 * Time range for chart data queries
 */
export type TimeRange = 'week' | 'month' | 'quarter' | 'year' | 'alltime' | 'custom'
/**
 * Trend classification for activity analysis
 */
export type Trend =
	/**
	 * Activity frequency improving (>10% increase)
	 */
	| 'Improving'
	/**
	 * Activity frequency declining (>10% decrease)
	 */
	| 'Declining'
	/**
	 * Activity frequency stable (within Â±10%)
	 */
	| 'Stable'
/**
 * Trend direction for assessment scores
 */
export type TrendDirection = 'improving' | 'worsening' | 'stable'
/**
 * Request to update an activity group
 */
export type UpdateActivityGroupRequest = { name: string | null; description: string | null }
/**
 * Request to update an activity
 */
export type UpdateActivityRequest = {
	name: string | null
	/**
	 * Color validated on deserialization via HexColor newtype
	 */
	color: HexColor | null
	icon: string | null
}
/**
 * Request to update an existing schedule
 */
export type UpdateScheduleRequest = {
	frequency: ScheduleFrequency | null
	time_of_day: string | null
	day_of_week: number | null
	day_of_month: number | null
	enabled: boolean | null
}

/** tauri-specta globals **/

import { invoke as TAURI_INVOKE, Channel as TAURI_CHANNEL } from '@tauri-apps/api/core'
import * as TAURI_API_EVENT from '@tauri-apps/api/event'
import { type WebviewWindow as __WebviewWindow__ } from '@tauri-apps/api/webviewWindow'

type __EventObj__<T> = {
	listen: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.listen<T>>
	once: (cb: TAURI_API_EVENT.EventCallback<T>) => ReturnType<typeof TAURI_API_EVENT.once<T>>
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>
}

export type Result<T, E> = { status: 'ok'; data: T } | { status: 'error'; error: E }

function __makeEvents__<T extends Record<string, any>>(mappings: Record<keyof T, string>) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>
			}
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T]

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case 'listen':
								return (arg: any) => TAURI_API_EVENT.listen(name, arg)
							case 'once':
								return (arg: any) => TAURI_API_EVENT.once(name, arg)
							case 'emit':
								return (arg: any) => TAURI_API_EVENT.emit(name, arg)
						}
					},
				})
			},
		}
	)
}
